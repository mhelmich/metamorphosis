// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/api_definitions.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		pb/api_definitions.proto
		pb/metamorphosis.proto

	It has these top-level messages:
		CreateTopicRequest
		CreateTopicResponse
		ListTopicsRequest
		ListTopicsResponse
		TopicMetadata
		PublishRequest
		PublishResponse
		SubscribeRequest
		LogRecord
		SubscribeResponse
		LogEntry
		LogSnapshot
		TopicMetadataSnapshot
		TopicMetadataOperation
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type CreateTopicRequest struct {
	TopicName string `protobuf:"bytes,1,opt,name=TopicName,proto3" json:"TopicName,omitempty"`
}

func (m *CreateTopicRequest) Reset()                    { *m = CreateTopicRequest{} }
func (m *CreateTopicRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateTopicRequest) ProtoMessage()               {}
func (*CreateTopicRequest) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{0} }

type CreateTopicResponse struct {
	Ok bool `protobuf:"varint,1,opt,name=Ok,proto3" json:"Ok,omitempty"`
}

func (m *CreateTopicResponse) Reset()         { *m = CreateTopicResponse{} }
func (m *CreateTopicResponse) String() string { return proto.CompactTextString(m) }
func (*CreateTopicResponse) ProtoMessage()    {}
func (*CreateTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorApiDefinitions, []int{1}
}

type ListTopicsRequest struct {
	NamePrefix string `protobuf:"bytes,1,opt,name=NamePrefix,proto3" json:"NamePrefix,omitempty"`
}

func (m *ListTopicsRequest) Reset()                    { *m = ListTopicsRequest{} }
func (m *ListTopicsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTopicsRequest) ProtoMessage()               {}
func (*ListTopicsRequest) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{2} }

type ListTopicsResponse struct {
	Metadata []*TopicMetadata `protobuf:"bytes,1,rep,name=metadata" json:"metadata,omitempty"`
}

func (m *ListTopicsResponse) Reset()                    { *m = ListTopicsResponse{} }
func (m *ListTopicsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTopicsResponse) ProtoMessage()               {}
func (*ListTopicsResponse) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{3} }

type TopicMetadata struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Size_ uint64 `protobuf:"varint,2,opt,name=Size,proto3" json:"Size,omitempty"`
}

func (m *TopicMetadata) Reset()                    { *m = TopicMetadata{} }
func (m *TopicMetadata) String() string            { return proto.CompactTextString(m) }
func (*TopicMetadata) ProtoMessage()               {}
func (*TopicMetadata) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{4} }

// Sending a publish request starts a new publisher session on metamorphosis.
// The first request in the stream requires the topic field to be set.
// Failure to do so will fail the session.
// From then on the provided entry will be appended to the log.
// Setting the topic field to a different value will have no effect (the value
// of the field will be ignored after the first request for the duration of the session).
// In order to publish to a different topic the stream needs to be closed and
// a new stream needs to be created.
// When a topic is provided that doesn't exist, an error will be returned.
type PublishRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=Topic,proto3" json:"Topic,omitempty"`
	EntryKey  []byte `protobuf:"bytes,2,opt,name=EntryKey,proto3" json:"EntryKey,omitempty"`
	EntryData []byte `protobuf:"bytes,3,opt,name=EntryData,proto3" json:"EntryData,omitempty"`
}

func (m *PublishRequest) Reset()                    { *m = PublishRequest{} }
func (m *PublishRequest) String() string            { return proto.CompactTextString(m) }
func (*PublishRequest) ProtoMessage()               {}
func (*PublishRequest) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{5} }

// For each publish request a corresponding response will be sent.
// The response will contain the entry key that has been committed by metamorphosis.
type PublishResponse struct {
	Error             string `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	CommittedEntryKey []byte `protobuf:"bytes,2,opt,name=CommittedEntryKey,proto3" json:"CommittedEntryKey,omitempty"`
	Offset            uint64 `protobuf:"varint,3,opt,name=Offset,proto3" json:"Offset,omitempty"`
}

func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }
func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()               {}
func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{6} }

// Sending a subcribe request starts a new subscription session on metamorphosis.
// The first request in the stream requires the topic and starting entry key fields to be set.
// The subcription topic is valid over the life time of the entire session and the value of the
// topic field will be ignored in subsequent requests in the stream.
// Failure to provide the name of an existing topic will result in closing the session with an error.
// The starting entry key is the entry at which the log will be read.
// The committed entry key field defines the place at which the log be started read within this session.
// metamorphosis is free to discard entries that have been read by a session whenever it seems fit.
// Failure to provide a reasonable combination of starting entry and committed entry will result in a failure and close of the session.
type SubscribeRequest struct {
	Topic             string `protobuf:"bytes,1,opt,name=Topic,proto3" json:"Topic,omitempty"`
	StartingOffset    uint64 `protobuf:"varint,2,opt,name=StartingOffset,proto3" json:"StartingOffset,omitempty"`
	CommittedEntryKey []byte `protobuf:"bytes,3,opt,name=CommittedEntryKey,proto3" json:"CommittedEntryKey,omitempty"`
}

func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()               {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{7} }

type LogRecord struct {
	Offset uint64 `protobuf:"varint,1,opt,name=Offset,proto3" json:"Offset,omitempty"`
	Key    []byte `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	Value  []byte `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *LogRecord) Reset()                    { *m = LogRecord{} }
func (m *LogRecord) String() string            { return proto.CompactTextString(m) }
func (*LogRecord) ProtoMessage()               {}
func (*LogRecord) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{8} }

type SubscribeResponse struct {
	Error   string       `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	Records []*LogRecord `protobuf:"bytes,2,rep,name=records" json:"records,omitempty"`
}

func (m *SubscribeResponse) Reset()                    { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string            { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()               {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) { return fileDescriptorApiDefinitions, []int{9} }

func init() {
	proto.RegisterType((*CreateTopicRequest)(nil), "pb.CreateTopicRequest")
	proto.RegisterType((*CreateTopicResponse)(nil), "pb.CreateTopicResponse")
	proto.RegisterType((*ListTopicsRequest)(nil), "pb.ListTopicsRequest")
	proto.RegisterType((*ListTopicsResponse)(nil), "pb.ListTopicsResponse")
	proto.RegisterType((*TopicMetadata)(nil), "pb.TopicMetadata")
	proto.RegisterType((*PublishRequest)(nil), "pb.PublishRequest")
	proto.RegisterType((*PublishResponse)(nil), "pb.PublishResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "pb.SubscribeRequest")
	proto.RegisterType((*LogRecord)(nil), "pb.LogRecord")
	proto.RegisterType((*SubscribeResponse)(nil), "pb.SubscribeResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MetamorphosisMetadataService service

type MetamorphosisMetadataServiceClient interface {
	// Creates a topic with the given name.
	// Returns an error if the topic already exists.
	CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*CreateTopicResponse, error)
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
}

type metamorphosisMetadataServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetamorphosisMetadataServiceClient(cc *grpc.ClientConn) MetamorphosisMetadataServiceClient {
	return &metamorphosisMetadataServiceClient{cc}
}

func (c *metamorphosisMetadataServiceClient) CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*CreateTopicResponse, error) {
	out := new(CreateTopicResponse)
	err := grpc.Invoke(ctx, "/pb.MetamorphosisMetadataService/CreateTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metamorphosisMetadataServiceClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	out := new(ListTopicsResponse)
	err := grpc.Invoke(ctx, "/pb.MetamorphosisMetadataService/ListTopics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MetamorphosisMetadataService service

type MetamorphosisMetadataServiceServer interface {
	// Creates a topic with the given name.
	// Returns an error if the topic already exists.
	CreateTopic(context.Context, *CreateTopicRequest) (*CreateTopicResponse, error)
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
}

func RegisterMetamorphosisMetadataServiceServer(s *grpc.Server, srv MetamorphosisMetadataServiceServer) {
	s.RegisterService(&_MetamorphosisMetadataService_serviceDesc, srv)
}

func _MetamorphosisMetadataService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetamorphosisMetadataServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MetamorphosisMetadataService/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetamorphosisMetadataServiceServer).CreateTopic(ctx, req.(*CreateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetamorphosisMetadataService_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetamorphosisMetadataServiceServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.MetamorphosisMetadataService/ListTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetamorphosisMetadataServiceServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetamorphosisMetadataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.MetamorphosisMetadataService",
	HandlerType: (*MetamorphosisMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTopic",
			Handler:    _MetamorphosisMetadataService_CreateTopic_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _MetamorphosisMetadataService_ListTopics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/api_definitions.proto",
}

// Client API for MetamorphosisPubSubService service

type MetamorphosisPubSubServiceClient interface {
	Publish(ctx context.Context, opts ...grpc.CallOption) (MetamorphosisPubSubService_PublishClient, error)
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (MetamorphosisPubSubService_SubscribeClient, error)
}

type metamorphosisPubSubServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetamorphosisPubSubServiceClient(cc *grpc.ClientConn) MetamorphosisPubSubServiceClient {
	return &metamorphosisPubSubServiceClient{cc}
}

func (c *metamorphosisPubSubServiceClient) Publish(ctx context.Context, opts ...grpc.CallOption) (MetamorphosisPubSubService_PublishClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MetamorphosisPubSubService_serviceDesc.Streams[0], c.cc, "/pb.MetamorphosisPubSubService/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &metamorphosisPubSubServicePublishClient{stream}
	return x, nil
}

type MetamorphosisPubSubService_PublishClient interface {
	Send(*PublishRequest) error
	Recv() (*PublishResponse, error)
	grpc.ClientStream
}

type metamorphosisPubSubServicePublishClient struct {
	grpc.ClientStream
}

func (x *metamorphosisPubSubServicePublishClient) Send(m *PublishRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *metamorphosisPubSubServicePublishClient) Recv() (*PublishResponse, error) {
	m := new(PublishResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metamorphosisPubSubServiceClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (MetamorphosisPubSubService_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MetamorphosisPubSubService_serviceDesc.Streams[1], c.cc, "/pb.MetamorphosisPubSubService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &metamorphosisPubSubServiceSubscribeClient{stream}
	return x, nil
}

type MetamorphosisPubSubService_SubscribeClient interface {
	Send(*SubscribeRequest) error
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type metamorphosisPubSubServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *metamorphosisPubSubServiceSubscribeClient) Send(m *SubscribeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *metamorphosisPubSubServiceSubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MetamorphosisPubSubService service

type MetamorphosisPubSubServiceServer interface {
	Publish(MetamorphosisPubSubService_PublishServer) error
	Subscribe(MetamorphosisPubSubService_SubscribeServer) error
}

func RegisterMetamorphosisPubSubServiceServer(s *grpc.Server, srv MetamorphosisPubSubServiceServer) {
	s.RegisterService(&_MetamorphosisPubSubService_serviceDesc, srv)
}

func _MetamorphosisPubSubService_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetamorphosisPubSubServiceServer).Publish(&metamorphosisPubSubServicePublishServer{stream})
}

type MetamorphosisPubSubService_PublishServer interface {
	Send(*PublishResponse) error
	Recv() (*PublishRequest, error)
	grpc.ServerStream
}

type metamorphosisPubSubServicePublishServer struct {
	grpc.ServerStream
}

func (x *metamorphosisPubSubServicePublishServer) Send(m *PublishResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *metamorphosisPubSubServicePublishServer) Recv() (*PublishRequest, error) {
	m := new(PublishRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MetamorphosisPubSubService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetamorphosisPubSubServiceServer).Subscribe(&metamorphosisPubSubServiceSubscribeServer{stream})
}

type MetamorphosisPubSubService_SubscribeServer interface {
	Send(*SubscribeResponse) error
	Recv() (*SubscribeRequest, error)
	grpc.ServerStream
}

type metamorphosisPubSubServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *metamorphosisPubSubServiceSubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *metamorphosisPubSubServiceSubscribeServer) Recv() (*SubscribeRequest, error) {
	m := new(SubscribeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MetamorphosisPubSubService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.MetamorphosisPubSubService",
	HandlerType: (*MetamorphosisPubSubServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _MetamorphosisPubSubService_Publish_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _MetamorphosisPubSubService_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/api_definitions.proto",
}

func (m *CreateTopicRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTopicRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TopicName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.TopicName)))
		i += copy(dAtA[i:], m.TopicName)
	}
	return i, nil
}

func (m *CreateTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListTopicsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTopicsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NamePrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.NamePrefix)))
		i += copy(dAtA[i:], m.NamePrefix)
	}
	return i, nil
}

func (m *ListTopicsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTopicsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApiDefinitions(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TopicMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *PublishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.EntryKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.EntryKey)))
		i += copy(dAtA[i:], m.EntryKey)
	}
	if len(m.EntryData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.EntryData)))
		i += copy(dAtA[i:], m.EntryData)
	}
	return i, nil
}

func (m *PublishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.CommittedEntryKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.CommittedEntryKey)))
		i += copy(dAtA[i:], m.CommittedEntryKey)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(m.Offset))
	}
	return i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if m.StartingOffset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(m.StartingOffset))
	}
	if len(m.CommittedEntryKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.CommittedEntryKey)))
		i += copy(dAtA[i:], m.CommittedEntryKey)
	}
	return i, nil
}

func (m *LogRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(m.Offset))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *SubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApiDefinitions(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Records) > 0 {
		for _, msg := range m.Records {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApiDefinitions(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintApiDefinitions(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CreateTopicRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TopicName)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	return n
}

func (m *CreateTopicResponse) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	return n
}

func (m *ListTopicsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.NamePrefix)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	return n
}

func (m *ListTopicsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovApiDefinitions(uint64(l))
		}
	}
	return n
}

func (m *TopicMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovApiDefinitions(uint64(m.Size_))
	}
	return n
}

func (m *PublishRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	l = len(m.EntryKey)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	l = len(m.EntryData)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	return n
}

func (m *PublishResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	l = len(m.CommittedEntryKey)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovApiDefinitions(uint64(m.Offset))
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	if m.StartingOffset != 0 {
		n += 1 + sovApiDefinitions(uint64(m.StartingOffset))
	}
	l = len(m.CommittedEntryKey)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	return n
}

func (m *LogRecord) Size() (n int) {
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovApiDefinitions(uint64(m.Offset))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	return n
}

func (m *SubscribeResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovApiDefinitions(uint64(l))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovApiDefinitions(uint64(l))
		}
	}
	return n
}

func sovApiDefinitions(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApiDefinitions(x uint64) (n int) {
	return sovApiDefinitions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateTopicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTopicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTopicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTopicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTopicsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTopicsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTopicsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTopicsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTopicsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTopicsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &TopicMetadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryKey = append(m.EntryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EntryKey == nil {
				m.EntryKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryData = append(m.EntryData[:0], dAtA[iNdEx:postIndex]...)
			if m.EntryData == nil {
				m.EntryData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedEntryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommittedEntryKey = append(m.CommittedEntryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CommittedEntryKey == nil {
				m.CommittedEntryKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingOffset", wireType)
			}
			m.StartingOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingOffset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedEntryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommittedEntryKey = append(m.CommittedEntryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CommittedEntryKey == nil {
				m.CommittedEntryKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &LogRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiDefinitions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiDefinitions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApiDefinitions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApiDefinitions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiDefinitions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApiDefinitions
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApiDefinitions
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApiDefinitions(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApiDefinitions = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApiDefinitions   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/api_definitions.proto", fileDescriptorApiDefinitions) }

var fileDescriptorApiDefinitions = []byte{
	// 554 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xce, 0x26, 0x69, 0x9b, 0x4c, 0xff, 0xe6, 0x6f, 0xb6, 0x69, 0x88, 0xac, 0xca, 0x8a, 0x56,
	0x02, 0x72, 0x80, 0x14, 0xa5, 0x07, 0xb8, 0x80, 0x10, 0xa1, 0xa7, 0x16, 0x12, 0x6d, 0x10, 0x57,
	0xb0, 0x93, 0x4d, 0xba, 0x6a, 0x9d, 0x35, 0xbb, 0x6b, 0x44, 0x39, 0xf0, 0x18, 0x5c, 0x79, 0x9d,
	0x1e, 0xfb, 0x08, 0x34, 0x4f, 0x82, 0x76, 0x63, 0x27, 0xb6, 0x03, 0xbd, 0xcd, 0x7c, 0x33, 0xf3,
	0xcd, 0x37, 0xab, 0xcf, 0x86, 0x56, 0xe8, 0x1f, 0x7b, 0x21, 0xff, 0x34, 0x61, 0x53, 0x3e, 0xe7,
	0x9a, 0x8b, 0xb9, 0xea, 0x86, 0x52, 0x68, 0x81, 0x8b, 0xa1, 0xef, 0x34, 0x66, 0x62, 0x26, 0x6c,
	0x7a, 0x6c, 0xa2, 0x65, 0x85, 0xf4, 0x00, 0xf7, 0x25, 0xf3, 0x34, 0xfb, 0x20, 0x42, 0x3e, 0xa6,
	0xec, 0x4b, 0xc4, 0x94, 0xc6, 0x47, 0x50, 0xb5, 0xf9, 0x7b, 0x2f, 0x60, 0x2d, 0xd4, 0x46, 0x9d,
	0x2a, 0x5d, 0x03, 0xe4, 0x21, 0x1c, 0x64, 0x66, 0x54, 0x28, 0xe6, 0x8a, 0xe1, 0x1a, 0x14, 0x07,
	0x97, 0xb6, 0xbb, 0x42, 0x8b, 0x83, 0x4b, 0x72, 0x02, 0xf5, 0x73, 0xae, 0xb4, 0x6d, 0x52, 0x09,
	0xb3, 0x0b, 0x60, 0x38, 0x86, 0x92, 0x4d, 0xf9, 0xb7, 0x98, 0x3a, 0x85, 0x90, 0x3e, 0xe0, 0xf4,
	0x50, 0x4c, 0xfd, 0x14, 0x2a, 0x01, 0xd3, 0xde, 0xc4, 0xd3, 0x5e, 0x0b, 0xb5, 0x4b, 0x9d, 0xdd,
	0x5e, 0xbd, 0x1b, 0xfa, 0x5d, 0xdb, 0xf5, 0x2e, 0x2e, 0xd0, 0x55, 0x0b, 0x79, 0x0e, 0x7b, 0x99,
	0x12, 0xc6, 0x50, 0x4e, 0x9d, 0x62, 0x63, 0x83, 0x8d, 0xf8, 0x77, 0xd6, 0x2a, 0xb6, 0x51, 0xa7,
	0x4c, 0x6d, 0x4c, 0x3e, 0x43, 0x6d, 0x18, 0xf9, 0x57, 0x5c, 0x5d, 0x24, 0x7a, 0x1b, 0xb0, 0x65,
	0xa9, 0xe2, 0xd1, 0x65, 0x82, 0x1d, 0xa8, 0x9c, 0xce, 0xb5, 0xbc, 0x3e, 0x63, 0xd7, 0x76, 0xfe,
	0x3f, 0xba, 0xca, 0xcd, 0xdb, 0xd9, 0xf8, 0xad, 0x11, 0x5b, 0xb2, 0xc5, 0x35, 0x40, 0x02, 0xf8,
	0x7f, 0xb5, 0x21, 0x3e, 0xae, 0x01, 0x5b, 0xa7, 0x52, 0x0a, 0x99, 0xac, 0xb0, 0x09, 0x7e, 0x02,
	0xf5, 0xbe, 0x08, 0x02, 0xae, 0x35, 0x9b, 0xe4, 0x76, 0x6d, 0x16, 0x70, 0x13, 0xb6, 0x07, 0xd3,
	0xa9, 0x62, 0xda, 0x6e, 0x2c, 0xd3, 0x38, 0x23, 0x3f, 0x60, 0x7f, 0x14, 0xf9, 0x6a, 0x2c, 0xb9,
	0xcf, 0xee, 0x3f, 0xe9, 0x11, 0xd4, 0x46, 0xda, 0x93, 0x9a, 0xcf, 0x67, 0x31, 0xd3, 0xf2, 0x61,
	0x72, 0xe8, 0xdf, 0x75, 0x95, 0xfe, 0xa1, 0x8b, 0x9c, 0x41, 0xf5, 0x5c, 0xcc, 0x28, 0x1b, 0x0b,
	0x39, 0x49, 0x89, 0x44, 0x69, 0x91, 0x78, 0x1f, 0x4a, 0xeb, 0xe3, 0x4c, 0x68, 0x24, 0x7e, 0xf4,
	0xae, 0x22, 0x16, 0x13, 0x2f, 0x13, 0x42, 0xa1, 0x9e, 0x3a, 0xe6, 0xde, 0xd7, 0x7b, 0x0c, 0x3b,
	0xd2, 0x2e, 0x55, 0xad, 0xa2, 0xf5, 0xcb, 0x9e, 0xf1, 0xcb, 0x4a, 0x0a, 0x4d, 0xaa, 0xbd, 0x5f,
	0x08, 0x8e, 0x8c, 0x4d, 0x02, 0x21, 0xc3, 0x0b, 0xa1, 0xb8, 0x4a, 0x3c, 0x33, 0x62, 0xf2, 0x2b,
	0x1f, 0x33, 0xfc, 0x1a, 0x76, 0x53, 0x66, 0xc7, 0x4d, 0xc3, 0xb3, 0xf9, 0xc5, 0x38, 0x0f, 0x36,
	0xf0, 0xa5, 0x3e, 0x52, 0xc0, 0x2f, 0x01, 0xd6, 0x96, 0xc6, 0x87, 0x56, 0x48, 0xfe, 0xbb, 0x70,
	0x9a, 0x79, 0x38, 0x19, 0xef, 0xfd, 0x44, 0xe0, 0x64, 0x14, 0x0e, 0x23, 0x7f, 0x14, 0xf9, 0x89,
	0xbe, 0x17, 0xb0, 0x13, 0x1b, 0x0a, 0x63, 0xc3, 0x91, 0xf5, 0xaf, 0x73, 0x90, 0xc1, 0x12, 0xd2,
	0x0e, 0x7a, 0x86, 0xf0, 0x2b, 0xa8, 0xae, 0x9e, 0x13, 0x37, 0x4c, 0x5f, 0xde, 0x2a, 0xce, 0x61,
	0x0e, 0x4d, 0xcf, 0xbf, 0x69, 0xdc, 0xdc, 0xb9, 0x85, 0xdb, 0x3b, 0xb7, 0x70, 0xb3, 0x70, 0xd1,
	0xed, 0xc2, 0x45, 0xbf, 0x17, 0x2e, 0xf2, 0xb7, 0xed, 0x7f, 0xe5, 0xe4, 0x4f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x04, 0x65, 0x9a, 0x7a, 0x8d, 0x04, 0x00, 0x00,
}
